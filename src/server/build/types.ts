import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs';
import { basename, join } from 'node:path';
import { logger } from '@shared/utils/logger';

interface InterfaceDefinition {
    name: string;
    comment?: string;
    fields: Array<{
        name: string;
        type: string;
        optional: boolean;
        comment?: string;
    }>;
}

interface EnumDefinition {
    name: string;
    comment?: string;
    values: Array<{
        name: string;
        value: string | number;
    }>;
}

export const generateLuaTypes = () => {
    logger.info('Generating Lua type definitions from Typescript...');

    const typesDir = join(__dirname, '../../../lua/generated/server/types');
    mkdirSync(typesDir, { recursive: true });

    const sharedTypesDir = join(__dirname, '../../../src/shared/types');

    parseAndGenerateTypes(join(sharedTypesDir, 'player.types.ts'), join(typesDir, 'player.lua'));

    generateMiscTypes(typesDir);

    logger.info('Type definitions generated');
};

const parseAndGenerateTypes = (tsFilePath: string, luaFilePath: string) => {
    if (!existsSync(tsFilePath)) {
        logger.warn(`TypeScript file not found: ${tsFilePath}`);
        return;
    }

    const content = readFileSync(tsFilePath, 'utf-8');
    const interfaces = parseInterfaces(content);
    const enums = parseEnums(content);

    let lua = `---@meta\n\n`;
    lua += `-- Auto-generated from ${basename(tsFilePath)}\n`;
    lua += `-- DO NOT EDIT THIS FILE MANUALLY\n`;
    lua += `-- Generated at: ${new Date().toISOString()}\n\n`;

    interfaces.forEach((iface) => {
        lua += generateLuaClass(iface);
        lua += '\n';
    });

    enums.forEach((enumDef) => {
        lua += generateLuaEnum(enumDef);
        lua += '\n';
    });

    writeFileSync(luaFilePath, lua);

    logger.info(
        `Generated ${basename(luaFilePath)} (${interfaces.length} types, ${enums.length} enums)`,
    );
};

const parseInterfaces = (content: string): InterfaceDefinition[] => {
    const interfaces: InterfaceDefinition[] = [];
    const interfaceRegex =
        /(?:\/\*\*\s*([\s\S]*?)\s*\*\/)?\s*export\s+interface\s+(\w+)\s*\{([^}]+)\}/g;

    for (const match of content.matchAll(interfaceRegex)) {
        const [, comment, name, body] = match;
        const fields = parseInterfaceFields(body);

        interfaces.push({
            name,
            comment: comment ? cleanComment(comment) : undefined,
            fields,
        });
    }

    return interfaces;
};

const parseInterfaceFields = (body: string): InterfaceDefinition['fields'] => {
    const fields: InterfaceDefinition['fields'] = [];
    const lines = body.split('\n');
    let currentComment: string | undefined;
    let i = 0;

    while (i < lines.length) {
        const trimmed = lines[i].trim();

        if (trimmed.startsWith('//')) {
            currentComment = trimmed.substring(2).trim();
            i++;
            continue;
        }

        const fieldStartMatch = trimmed.match(/^(\w+)(\?)?:\s*(.*)/);

        if (fieldStartMatch) {
            const [, name, optional, typeStart] = fieldStartMatch;
            let type = typeStart;

            if (typeStart.trimStart().startsWith('{')) {
                let braceCount = 0;
                let objectType = '';
                let j = i;

                outerLoop: while (j < lines.length) {
                    const line = lines[j];
                    const lineContent = j === i ? typeStart : line;

                    for (const char of lineContent) {
                        objectType += char;

                        if (char === '{') braceCount++;
                        if (char === '}') braceCount--;

                        if (braceCount === 0) {
                            break outerLoop;
                        }
                    }

                    objectType += ' ';
                    j++;
                }

                type = convertInlineObjectToLua(objectType);
                i = j + 1;
            } else {
                type = type.replace(/;$/, '').trim();
                i++;
            }

            fields.push({
                name,
                type: type.trim(),
                optional: !!optional,
                comment: currentComment,
            });

            currentComment = undefined;
        } else {
            i++;
        }
    }

    return fields;
};

const parseEnums = (content: string): EnumDefinition[] => {
    const enums: EnumDefinition[] = [];
    const enumRegex = /(?:\/\*\*\s*([\s\S]*?)\s*\*\/)?\s*export\s+enum\s+(\w+)\s*\{([^}]+)\}/g;

    for (const match of content.matchAll(enumRegex)) {
        const [, comment, name, body] = match;
        const values = parseEnumValues(body);

        enums.push({
            name,
            comment: comment ? cleanComment(comment) : undefined,
            values,
        });
    }

    return enums;
};

const parseEnumValues = (body: string): EnumDefinition['values'] => {
    const values: EnumDefinition['values'] = [];
    const lines = body.split('\n');

    for (const line of lines) {
        const trimmed = line.trim();
        const match = trimmed.match(/^(\w+)\s*=\s*(['"]?)([^,'"]+)\2,?/);

        if (match) {
            const [, name, , value] = match;

            values.push({
                name,
                value: Number.isNaN(Number(value)) ? value : Number(value),
            });
        }
    }

    return values;
};

const generateLuaClass = (iface: InterfaceDefinition): string => {
    let lua = '';

    if (iface.comment) {
        lua += `---${iface.comment}\n`;
    }

    lua += `---@class ${iface.name}\n`;

    iface.fields.forEach((field) => {
        if (field.comment) {
            lua += `---@field ${field.name} ${convertTypeToLua(field.type)}${field.optional ? '?' : ''} ${field.comment}\n`;
        } else {
            lua += `---@field ${field.name} ${convertTypeToLua(field.type)}${field.optional ? '?' : ''}\n`;
        }
    });

    return lua;
};

const generateLuaEnum = (enumDef: EnumDefinition): string => {
    let lua = '';

    if (enumDef.comment) {
        lua += `---${enumDef.comment}\n`;
    }

    const values = enumDef.values.map((v) => `'${v.name}'`).join(' | ');

    lua += `---@alias ${enumDef.name} ${values}\n`;

    return lua;
};

const convertTypeToLua = (tsType: string): string => {
    tsType = tsType.trim();

    if (tsType.endsWith('[]')) {
        const elementType = convertTypeToLua(tsType.slice(0, -2));
        return `${elementType}[]`;
    }

    const recordOrMapMatch = tsType.match(/^(?:Record|Map)<\s*([^,]+)\s*,\s*(.+)\s*>$/);

    if (recordOrMapMatch) {
        const keyType = convertTypeToLua(recordOrMapMatch[1]);
        const valueType = convertTypeToLua(recordOrMapMatch[2]);
        return `table<${keyType}, ${valueType}>`;
    }

    if (tsType.includes('|')) {
        const types = tsType.split('|').map((t) => convertTypeToLua(t.trim()));
        return types.join('|');
    }

    if (tsType.includes('<')) {
        const baseType = tsType.split('<')[0];

        if (baseType === 'Array') {
            const innerType = tsType.match(/<(.+)>/)?.[1];
            return innerType ? `${convertTypeToLua(innerType)}[]` : 'table';
        }

        return 'table';
    }

    const typeMap: Record<string, string> = {
        string: 'string',
        number: 'number',
        boolean: 'boolean',
        any: 'any',
        unknown: 'any',
        void: 'nil',
        null: 'nil',
        undefined: 'nil',
        object: 'table',
    };

    if (typeMap[tsType]) {
        return typeMap[tsType];
    }

    return tsType;
};

const convertInlineObjectToLua = (objectType: string): string => {
    const inner = objectType.replace(/^\{/, '').replace(/\}$/, '').trim();

    const fieldParts: string[] = [];
    let i = 0;

    while (i < inner.length) {
        while (i < inner.length && /\s/.test(inner[i])) i++;

        if (i >= inner.length) break;

        if (inner[i] === '[') {
            i++;

            while (i < inner.length && /\s/.test(inner[i])) i++;

            while (i < inner.length && /\w/.test(inner[i])) i++;

            while (i < inner.length && /[\s:]/.test(inner[i])) i++;

            let keyType = '';
            while (i < inner.length && inner[i] !== ']') {
                keyType += inner[i];
                i++;
            }

            i++;

            while (i < inner.length && (inner[i] === ':' || /\s/.test(inner[i]))) i++;

            let valueType = '';
            while (i < inner.length && inner[i] !== ';' && inner[i] !== ',') {
                valueType += inner[i];
                i++;
            }

            if (i < inner.length && (inner[i] === ';' || inner[i] === ',')) i++;

            const luaKeyType = convertTypeToLua(keyType.trim());
            const luaValueType = convertTypeToLua(valueType.trim());
            fieldParts.push(`[${luaKeyType}]: ${luaValueType}`);
            continue;
        }

        let fieldName = '';
        while (i < inner.length && /\w/.test(inner[i])) {
            fieldName += inner[i];
            i++;
        }

        if (!fieldName) {
            i++;
            continue;
        }

        let optional = false;
        while (i < inner.length && /\s/.test(inner[i])) i++;
        if (inner[i] === '?') {
            optional = true;
            i++;
        }

        while (i < inner.length && (inner[i] === ':' || /\s/.test(inner[i]))) i++;

        let fieldType = '';

        if (inner[i] === '{') {
            let braceCount = 0;
            const startIndex = i;

            while (i < inner.length) {
                if (inner[i] === '{') braceCount++;
                if (inner[i] === '}') braceCount--;

                i++;

                if (braceCount === 0) break;
            }

            const nestedObject = inner.slice(startIndex, i);
            fieldType = convertInlineObjectToLua(nestedObject);
        } else {
            while (i < inner.length && inner[i] !== ';' && inner[i] !== ',') {
                fieldType += inner[i];
                i++;
            }
            fieldType = convertTypeToLua(fieldType.trim());
        }

        if (i < inner.length && (inner[i] === ';' || inner[i] === ',')) i++;

        fieldParts.push(`${fieldName}: ${fieldType}${optional ? '?' : ''}`);
    }

    return `{ ${fieldParts.join(', ')} }`;
};

const cleanComment = (comment: string): string => {
    return comment
        .replace(/^\s*\*\s*/gm, '')
        .replace(/\n/g, ' ')
        .trim();
};

const generateMiscTypes = (outputDir: string) => {
    const lua = `---@meta

-- Auto-generated miscellaneous types used by the Bridge SDK
-- DO NOT EDIT THIS FILE MANUALLY
-- Generated at: ${new Date().toISOString()}

---@class TransactionResult
---@field success boolean Transaction succeeded
---@field reason string|nil Failure reason

---@class EventBuilder
---@field eventName string Event name
---@field filters function[] Filter functions
---@field handler function|nil Event handler
---@field once boolean Fire only once
---@field forSource number|nil Specific source filter
---@field Filter fun(self: EventBuilder, fn: function): EventBuilder Add filter
---@field For fun(self: EventBuilder, source: number): EventBuilder Filter by source
---@field Once fun(self: EventBuilder): EventBuilder Fire only once
---@field Do fun(self: EventBuilder, fn: function): EventBuilder Set handler
`;

    writeFileSync(join(outputDir, 'misc.lua'), lua);
    logger.info('Generated misc.lua');
};
