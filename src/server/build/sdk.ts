import { mkdirSync, writeFileSync } from 'node:fs';
import { dirname, join } from 'node:path';
import { DevFrameworkAdapter } from '@server/adapters/framework/dev';
import { registerModules } from '@server/registry/module-registry';
import { registry } from '@server/registry/registry';
import type { ParameterDef, RPCMethod } from '@server/registry/types';
import { capitalize } from '@shared/utils/helpers';
import { logger } from '@shared/utils/logger';

export const generateServerSDK = () => {
    logger.info('Generating server Lua SDK...');
    logger.info('Registering modules with dev adapters...');

    const devFrameworkAdapter = new DevFrameworkAdapter();

    const modules = registerModules(devFrameworkAdapter);

    logger.info(`Registered ${modules.length} modules`);

    const methods = registry.getAll();

    if (methods.length === 0) {
        logger.warn('No methods registered, skipping SDK generation');
        return;
    }

    logger.info(`Found ${methods.length} RPC methods`);

    const moduleMap = new Map<string, typeof methods>();

    methods.forEach((method) => {
        const [moduleName] = method.name.split('.');

        if (!moduleMap.has(moduleName)) {
            moduleMap.set(moduleName, []);
        }

        moduleMap.get(moduleName)?.push(method);
    });

    logger.info(`Generating SDK for ${moduleMap.size} modules...`);

    moduleMap.forEach((methods, moduleName) => {
        generateModuleSDK(moduleName, methods);
    });

    logger.info(`Generated SDK for ${moduleMap.size} modules (${methods.length} methods)`);
};

const generateModuleSDK = (moduleName: string, methods: RPCMethod[]) => {
    const className = `${capitalize(moduleName)}SDK`;
    const mutations = methods.filter((m) => m.category === 'mutation');
    const queries = methods.filter((m) => m.category === 'query');

    let lua = `
-- Auto-generated ${className}
-- DO NOT EDIT THIS FILE MANUALLY
-- Generated at: ${new Date().toISOString()}

---@class ${className}
---@field source number Player server ID
---@field operations table[] Queued operations
local ${className} = {}
${className}.__index = ${className}

---Create a new ${className} instance
---@param source number Player server ID
---@return ${className}
function ${className}:new(source)
    local instance = setmetatable({}, ${className})
    instance.source = source
    instance.operations = {}
    return instance
end

`;

    mutations.forEach((method) => {
        const [, methodName] = method.name.split('.');
        const fnName = capitalize(methodName);
        const params = method.params?.slice(1) || []; // Skip 'source' param
        const paramNames = params.map((p: ParameterDef) => p.name).join(', ');

        lua += `---${method.description || method.name}\n`;

        params.forEach((p: ParameterDef) => {
            lua += `---@param ${p.name} ${luaType(p.type)}${p.optional ? '?' : ''}\n`;
        });

        lua += `---@return ${className}\n`;
        lua += `function ${className}:${fnName}(${paramNames})\n`;
        lua += `    table.insert(self.operations, {\n`;
        lua += `        type = 'call',\n`;
        lua += `        method = '${method.name}',\n`;
        lua += `        args = {self.source${paramNames ? `, ${paramNames}` : ''}}\n`;
        lua += `    })\n`;
        lua += `    return self\n`;
        lua += `end\n\n`;
    });

    queries.forEach((method) => {
        const [, methodName] = method.name.split('.');
        const fnName = capitalize(methodName);
        const params = method.params?.slice(1) || [];
        const paramNames = params.map((p: ParameterDef) => p.name).join(', ');

        lua += `---${method.description || method.name}\n`;

        params.forEach((p: ParameterDef) => {
            lua += `---@param ${p.name} ${luaType(p.type)}${p.optional ? '?' : ''}\n`;
        });

        lua += `---@return ${luaType(method.returns || 'any')}\n`;
        lua += `function ${className}:${fnName}(${paramNames})\n`;
        lua += `    return exports['bridge']:_call('${method.name}', self.source${paramNames ? `, ${paramNames}` : ''})\n`;
        lua += `end\n\n`;
    });

    lua += `---Execute all queued operations\n`;
    lua += `---@return ${className}\n`;
    lua += `function ${className}:Execute()\n`;
    lua += `    for _, op in ipairs(self.operations) do\n`;
    lua += `        if op.type == 'call' then\n`;
    lua += `            exports['bridge']:_call(op.method, table.unpack(op.args))\n`;
    lua += `        end\n`;
    lua += `    end\n`;
    lua += `    self.operations = {}\n`;
    lua += `    return self\n`;
    lua += `end\n\n`;

    lua += `---Add validation before execution\n`;
    lua += `---@param fn function Validation function\n`;
    lua += `---@return ${className}\n`;
    lua += `function ${className}:Validate(fn)\n`;
    lua += `    local valid, reason = fn(self)\n`;
    lua += `    if not valid then\n`;
    lua += `        error(reason or 'Validation failed')\n`;
    lua += `    end\n`;
    lua += `    return self\n`;
    lua += `end\n\n`;

    lua += `return ${className}\n`;

    const outputPath = join(__dirname, `../../../lua/generated/server/sdk/${moduleName}.lua`);
    mkdirSync(dirname(outputPath), { recursive: true });
    writeFileSync(outputPath, lua);
};

function luaType(tsType: string): string {
    const typeMap: Record<string, string> = {
        number: 'number',
        string: 'string',
        boolean: 'boolean',
        object: 'table',
        any: 'any',
        void: 'nil',
    };

    if (tsType.includes('|')) {
        const types = tsType.split('|').map((t) => t.trim());

        return types[0];
    }

    if (tsType.endsWith('[]')) {
        return 'table';
    }

    return typeMap[tsType] || tsType;
}

generateServerSDK();
