import { mkdirSync, writeFileSync } from 'node:fs';
import { dirname, join } from 'node:path';
import { DevFrameworkAdapter } from '@server/adapters/framework/dev';
import type { RPCMethodConfig } from '@server/decorators/rpc';
import { registerModules } from '@server/registry/module-registry';
import { registry } from '@server/registry/registry';
import type { ParameterDef, RPCMethod } from '@server/registry/types';
import { capitalize } from '@shared/utils/helpers';
import { logger } from '@shared/utils/logger';
import { generateLuaTypes } from './types';

export const generateServerSDK = () => {
    logger.info('Generating server Lua SDK...');
    logger.info('Registering modules with dev adapters...');

    const devFrameworkAdapter = new DevFrameworkAdapter();

    const modules = registerModules(devFrameworkAdapter);

    logger.info(`Registered ${modules.length} modules`);

    const methods = registry.getAll();

    if (methods.length === 0) {
        logger.warn('No methods registered, skipping SDK generation');
        return;
    }

    logger.info(`Found ${methods.length} RPC methods`);

    generateLuaTypes();

    const moduleMap = new Map<string, typeof methods>();

    methods.forEach((method) => {
        const [moduleName] = method.name.split('.');

        if (!moduleMap.has(moduleName)) {
            moduleMap.set(moduleName, []);
        }

        moduleMap.get(moduleName)?.push(method);
    });

    logger.info(`Generating SDK for ${moduleMap.size} modules...`);

    moduleMap.forEach((methods, moduleName) => {
        generateModuleSDK(moduleName, methods);
    });

    generateMainSDK(Array.from(moduleMap.keys()));
    generateTransactionSDK(moduleMap);

    logger.info(`Generated SDK for ${moduleMap.size} modules (${methods.length} methods)`);
};

const generateModuleSDK = (moduleName: string, methods: RPCMethod[]) => {
    const className = `${capitalize(moduleName)}SDK`;
    const mutations = methods.filter((m) => m.category === 'mutation');
    const queries = methods.filter((m) => m.category === 'query');

    let lua = `
-- Auto-generated ${className}
-- DO NOT EDIT THIS FILE MANUALLY
-- Generated at: ${new Date().toISOString()}

---@class ${className}
---@field source number Player server ID
---@field operations table[] Queued operations
local ${className} = {}
${className}.__index = ${className}

---Create a new ${className} instance
---@param source number Player server ID
---@return ${className}
function ${className}:new(source)
    local instance = setmetatable({}, ${className})
    instance.source = source
    instance.operations = {}
    return instance
end

`;

    mutations.forEach((method) => {
        const [, methodName] = method.name.split('.');
        const fnName = capitalize(methodName);
        const params = method.params?.slice(1) || []; // Skip 'source' param
        const paramNames = params.map((p: ParameterDef) => p.name).join(', ');

        lua += `---${method.description || method.name}\n`;

        params.forEach((p: ParameterDef) => {
            lua += `---@param ${p.name} ${luaType(p.type)}${p.optional ? '?' : ''}\n`;
        });

        lua += `---@return ${className}\n`;
        lua += `function ${className}:${fnName}(${paramNames})\n`;
        lua += `    table.insert(self.operations, {\n`;
        lua += `        type = 'call',\n`;
        lua += `        method = '${method.name}',\n`;
        lua += `        args = {self.source${paramNames ? `, ${paramNames}` : ''}}\n`;
        lua += `    })\n`;
        lua += `    return self\n`;
        lua += `end\n\n`;
    });

    queries.forEach((method) => {
        const [, methodName] = method.name.split('.');
        const fnName = capitalize(methodName);
        const params = method.params?.slice(1) || [];
        const paramNames = params.map((p: ParameterDef) => p.name).join(', ');

        lua += `---${method.description || method.name}\n`;

        params.forEach((p: ParameterDef) => {
            lua += `---@param ${p.name} ${luaType(p.type)}${p.optional ? '?' : ''}\n`;
        });

        lua += `---@return ${luaType(method.returns || 'any')}\n`;
        lua += `function ${className}:${fnName}(${paramNames})\n`;
        lua += `    return exports['bridge']:_call('${method.name}', self.source${paramNames ? `, ${paramNames}` : ''})\n`;
        lua += `end\n\n`;
    });

    lua += `---Execute all queued operations\n`;
    lua += `---@return ${className}\n`;
    lua += `function ${className}:Execute()\n`;
    lua += `    for _, op in ipairs(self.operations) do\n`;
    lua += `        if op.type == 'call' then\n`;
    lua += `            exports['bridge']:_call(op.method, table.unpack(op.args))\n`;
    lua += `        end\n`;
    lua += `    end\n`;
    lua += `    self.operations = {}\n`;
    lua += `    return self\n`;
    lua += `end\n\n`;

    lua += `---Add validation before execution\n`;
    lua += `---@param fn function Validation function\n`;
    lua += `---@return ${className}\n`;
    lua += `function ${className}:Validate(fn)\n`;
    lua += `    local valid, reason = fn(self)\n`;
    lua += `    if not valid then\n`;
    lua += `        error(reason or 'Validation failed')\n`;
    lua += `    end\n`;
    lua += `    return self\n`;
    lua += `end\n\n`;

    lua += `return ${className}\n`;

    const outputPath = join(__dirname, `../../../lua/generated/server/sdk/${moduleName}.lua`);
    mkdirSync(dirname(outputPath), { recursive: true });
    writeFileSync(outputPath, lua);

    logger.info(`Generated ${moduleName}.lua (${methods.length} methods)`);
};

const generateMainSDK = (moduleNames: string[]) => {
    let lua = `
-- Auto-generated Bridge SDK (Server)
-- DO NOT EDIT THIS FILE MANUALLY
-- Generated at: ${new Date().toISOString()}

`;

    moduleNames.forEach((moduleName) => {
        const className = `${capitalize(moduleName)}SDK`;
        lua += `---@class ${className}\n`;
        lua += `local ${className} = require('generated/server/sdk/${moduleName}')\n`;
    });

    lua += `---@class TransactionSDK\n`;
    lua += `local TransactionSDK = require('generated/server/sdk/transaction')\n\n`;

    lua += `---@class BridgeSDK\n`;
    lua += `local BridgeSDK = {}\n\n`;

    moduleNames.forEach((moduleName) => {
        const className = `${capitalize(moduleName)}SDK`;
        const fnName = capitalize(moduleName);

        lua += `---Create a new ${fnName} SDK instance\n`;
        lua += `---@param source number Player server ID\n`;
        lua += `---@return ${className}\n`;
        lua += `function BridgeSDK:${fnName}(source)\n`;
        lua += `    return ${className}:new(source)\n`;
        lua += `end\n\n`;
    });

    lua += `---Create a new Transaction\n`;
    lua += `---@return TransactionSDK\n`;
    lua += `function BridgeSDK:Transaction()\n`;
    lua += `    return TransactionSDK:new()\n`;
    lua += `end\n\n`;

    lua += `---Build an event listener\n`;
    lua += `---@param eventName string Event name to listen to\n`;
    lua += `---@return EventBuilder\n`;
    lua += `function BridgeSDK:On(eventName)\n`;
    lua += `    ---@class EventBuilder\n`;
    lua += `    local builder = {\n`;
    lua += `        eventName = eventName,\n`;
    lua += `        filters = {},\n`;
    lua += `        handler = nil,\n`;
    lua += `        once = false,\n`;
    lua += `        forSource = nil\n`;
    lua += `    }\n\n`;
    lua += `    ---Add a filter function\n`;
    lua += `    ---@param fn function Filter function\n`;
    lua += `    ---@return EventBuilder\n`;
    lua += `    function builder:Filter(fn)\n`;
    lua += `        table.insert(self.filters, fn)\n`;
    lua += `        return self\n`;
    lua += `    end\n\n`;
    lua += `    ---Filter events for specific source\n`;
    lua += `    ---@param source number Player source\n`;
    lua += `    ---@return EventBuilder\n`;
    lua += `    function builder:For(source)\n`;
    lua += `        self.forSource = source\n`;
    lua += `        return self\n`;
    lua += `    end\n\n`;
    lua += `    ---Listen only once\n`;
    lua += `    ---@return EventBuilder\n`;
    lua += `    function builder:Once()\n`;
    lua += `        self.once = true\n`;
    lua += `        return self\n`;
    lua += `    end\n\n`;
    lua += `    ---Set the event handler\n`;
    lua += `    ---@param fn function Handler function\n`;
    lua += `    ---@return EventBuilder\n`;
    lua += `    function builder:Do(fn)\n`;
    lua += `        self.handler = fn\n`;
    lua += `        local handlerFn = function(...)\n`;
    lua += `            local args = {...}\n`;
    lua += `            if self.forSource and args[1] ~= self.forSource then\n`;
    lua += `                return\n`;
    lua += `            end\n`;
    lua += `            for _, filter in ipairs(self.filters) do\n`;
    lua += `                if not filter(...) then\n`;
    lua += `                    return\n`;
    lua += `                end\n`;
    lua += `            end\n`;
    lua += `            fn(...)\n`;
    lua += `        end\n`;
    lua += `        AddEventHandler(self.eventName, handlerFn)\n`;
    lua += `        return self\n`;
    lua += `    end\n\n`;
    lua += `    return builder\n`;
    lua += `end\n\n`;

    lua += `---Get the Bridge SDK\n`;
    lua += `---@return BridgeSDK\n`;
    lua += `exports('SDK', function()\n`;
    lua += `    return BridgeSDK\n`;
    lua += `end)\n`;

    const outputPath = join(__dirname, `../../../lua/generated/server/sdk.lua`);
    mkdirSync(dirname(outputPath), { recursive: true });
    writeFileSync(outputPath, lua);

    logger.info('Generated sdk.lua (main entry point)');
};

const generateTransactionSDK = (modules: Map<string, RPCMethodConfig[]>) => {
    const allMutations: RPCMethodConfig[] = [];

    modules.forEach((methods) => {
        allMutations.push(...methods.filter((m) => m.category === 'mutation'));
    });

    let lua = `
-- Auto-generated Transaction SDK (Server)
-- DO NOT EDIT THIS FILE MANUALLY
-- Generated at: ${new Date().toISOString()}

---@class TransactionSDK
---@field source number|nil Player source
---@field operations table[] Queued operations
---@field validators function[] Validation functions
---@field onSuccess function|nil Success callback
---@field onFailure function|nil Failure callback
local TransactionSDK = {}
TransactionSDK.__index = TransactionSDK

---Create a new transaction
---@return TransactionSDK
function TransactionSDK:new()
    local instance = setmetatable({}, TransactionSDK)
    instance.source = nil
    instance.operations = {}
    instance.validators = {}
    instance.onSuccess = nil
    instance.onFailure = nil
    return instance
end

---Set the source player for this transaction
---@param source number Player server ID
---@return TransactionSDK
function TransactionSDK:From(source)
    self.source = source
    return self
end

`;

    allMutations.forEach((method) => {
        const [, methodName] = method.name.split('.');
        const fnName = capitalize(methodName);
        const params = method.params?.slice(1) || [];
        const paramNames = params.map((p) => p.name).join(', ');

        lua += `---${method.description || method.name}\n`;
        params.forEach((p) => {
            lua += `---@param ${p.name} ${luaType(p.type)}${p.optional ? '?' : ''} ${p.description || ''}\n`;
        });
        lua += `---@return TransactionSDK\n`;
        lua += `function TransactionSDK:${fnName}(${paramNames})\n`;
        lua += `    table.insert(self.operations, {\n`;
        lua += `        type = '${method.name}',\n`;
        lua += `        args = {${paramNames}},\n`;
        lua += `        validate = ${methodName.toLowerCase().includes('remove') ? 'true' : 'false'}\n`;
        lua += `    })\n`;
        lua += `    return self\n`;
        lua += `end\n\n`;
    });

    lua += `---Add custom validation
---@param fn fun(tx: TransactionSDK): boolean, string? Validation function
---@return TransactionSDK
function TransactionSDK:Validate(fn)
    table.insert(self.validators, fn)
    return self
end

---Set success callback
---@param fn function Success callback
---@return TransactionSDK
function TransactionSDK:OnSuccess(fn)
    self.onSuccess = fn
    return self
end

---Set failure callback
---@param fn fun(reason: string) Failure callback with reason
---@return TransactionSDK
function TransactionSDK:OnFailure(fn)
    self.onFailure = fn
    return self
end

---Commit the transaction (execute all operations atomically)
---@return TransactionResult
function TransactionSDK:Commit()
    if not self.source then
        error('Transaction source not set. Use :From(source) first.')
    end
    
    -- Run custom validators
    for _, validator in ipairs(self.validators) do
        local valid, reason = validator(self)
        if not valid then
            if self.onFailure then
                self.onFailure(reason or 'Validation failed')
            end
            return {success = false, reason = reason}
        end
    end
    
    -- Execute all operations
    for _, op in ipairs(self.operations) do
        local success = exports['bridge']:_call(op.type, self.source, table.unpack(op.args))
        if not success then
            if self.onFailure then
                self.onFailure('Operation failed: ' .. op.type)
            end
            return {success = false, reason = 'operation_failed'}
        end
    end
    
    if self.onSuccess then
        self.onSuccess()
    end
    
    return {success = true}
end

return TransactionSDK
`;

    const outputPath = join(__dirname, `../../../lua/generated/server/sdk/transaction.lua`);
    mkdirSync(dirname(outputPath), { recursive: true });
    writeFileSync(outputPath, lua);

    logger.info(`Generated transaction.lua (${allMutations.length} mutations)`);
};

function luaType(tsType: string): string {
    const typeMap: Record<string, string> = {
        number: 'number',
        string: 'string',
        boolean: 'boolean',
        object: 'table',
        any: 'any',
        void: 'nil',
    };

    if (tsType.includes('|')) {
        const types = tsType.split('|').map((t) => t.trim());

        return types[0];
    }

    if (tsType.endsWith('[]')) {
        return 'table';
    }

    return typeMap[tsType] || tsType;
}

generateServerSDK();
